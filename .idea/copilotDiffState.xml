<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/Main.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/Main.md" />
              <option name="updatedContent" value="# Main.java&#10;&#10;This file contains the main entry point for the Spring Boot application.&#10;&#10;```java&#10;package org.example;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;import org.springframework.cache.annotation.EnableCaching;&#10;&#10;@SpringBootApplication&#10;@EnableScheduling&#10;@EnableCaching&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(Main.class, args);&#10;    }&#10;}&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/test_import.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test_import.sh" />
              <option name="updatedContent" value="#!/usr/bin/env zsh&#10;set -euo pipefail&#10;&#10;BASE=${BASE:-http://localhost:8080}&#10;CSV=${CSV:-tmp/sample_import.csv}&#10;DEV=${DEV:-true}&#10;&#10;info() { echo &quot;[INFO] $1&quot;; }&#10;err() { echo &quot;[ERROR] $1&quot; &gt;&amp;2; }&#10;&#10;info &quot;Checking server health at $BASE/actuator/health&quot;&#10;if ! curl -sSf &quot;$BASE/actuator/health&quot; &gt;/dev/null; then&#10;  err &quot;Server is not up. Start with: SPRING_DATASOURCE_USERNAME=postgres SPRING_DATASOURCE_PASSWORD=rmkec ./gradlew bootRun -Dapp.dev.enabled=true&quot;&#10;  exit 1&#10;fi&#10;&#10;info &quot;Starting async import via /admin/imports using $CSV&quot;&#10;HTTP_CODE=$(curl -s -o /tmp/import_response.json -w &quot;%{http_code}&quot; -X POST -F &quot;file=@${CSV}&quot; &quot;$BASE/admin/imports&quot;)&#10;cat /tmp/import_response.json | jq . || cat /tmp/import_response.json || true&#10;if [[ &quot;$HTTP_CODE&quot; != &quot;202&quot; &amp;&amp; &quot;$HTTP_CODE&quot; != &quot;200&quot; ]]; then&#10;  err &quot;Import start failed, HTTP $HTTP_CODE&quot;&#10;  exit 2&#10;fi&#10;&#10;JOB_ID=$(jq -r '.jobId // .job_id // empty' /tmp/import_response.json 2&gt;/dev/null || true)&#10;if [[ -z &quot;$JOB_ID&quot; ]]; then&#10;  err &quot;No jobId returned in response. Check /tmp/import_response.json&quot;&#10;  exit 3&#10;fi&#10;info &quot;jobId=$JOB_ID&quot;&#10;&#10;info &quot;Polling job status at /admin/imports/$JOB_ID&quot;&#10;for i in {1..30}; do&#10;  STATUS_JSON=$(curl -s &quot;$BASE/admin/imports/$JOB_ID&quot;)&#10;  STATUS=$(echo &quot;$STATUS_JSON&quot; | jq -r '.status // empty' 2&gt;/dev/null || true)&#10;  echo &quot;$STATUS_JSON&quot; | jq . || echo &quot;$STATUS_JSON&quot;&#10;  if [[ &quot;$STATUS&quot; == &quot;SUCCESS&quot; || &quot;$STATUS&quot; == &quot;PARTIAL&quot; || &quot;$STATUS&quot; == &quot;FAILED&quot; ]]; then&#10;    break&#10;  fi&#10;  sleep 1&#10;done&#10;&#10;info &quot;Fetching errors JSON at /admin/imports/$JOB_ID/errors&quot;&#10;curl -s &quot;$BASE/admin/imports/$JOB_ID/errors?page=0&amp;size=50&quot; | jq . || true&#10;&#10;info &quot;Downloading errors CSV at /admin/imports/$JOB_ID/errors/csv&quot;&#10;curl -s &quot;$BASE/admin/imports/$JOB_ID/errors/csv&quot; -o &quot;import_errors_${JOB_ID}.csv&quot; || true&#10;ls -l &quot;import_errors_${JOB_ID}.csv&quot; || true&#10;&#10;info &quot;Done.&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/AgentService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/AgentService.java" />
              <option name="updatedContent" value="package com.myteam.agent.core;&#10;&#10;import com.myteam.agent.core.dto.AgentRequest;&#10;import com.myteam.agent.core.dto.AgentResponse;&#10;&#10;public interface AgentService {&#10;&#10;    AgentResponse execute(AgentRequest request);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/AgentServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/AgentServiceImpl.java" />
              <option name="updatedContent" value="package com.myteam.agent.core;&#10;&#10;import com.myteam.agent.core.dto.AgentRequest;&#10;import com.myteam.agent.core.dto.AgentResponse;&#10;import com.myteam.agent.core.dto.ToolInvocation;&#10;import com.myteam.agent.core.policy.RbacPolicyMapper;&#10;import com.myteam.agent.mcp.McpLeader;&#10;import org.example.service.AuditLogService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.UUID;&#10;&#10;@Service&#10;public class AgentServiceImpl implements AgentService {&#10;&#10;    @Autowired&#10;    private McpLeader mcpLeader;&#10;&#10;    @Autowired&#10;    private AuditLogService auditLogService; // Assuming from existing&#10;&#10;    @Override&#10;    public AgentResponse execute(AgentRequest request) {&#10;        // Step 1: RBAC Check&#10;        if (!RbacPolicyMapper.canExecuteAgent(request.getRole())) {&#10;            String auditId = auditLogService.log(request.getActor(), &quot;AGENT_EXECUTE_DENIED&quot;, &quot;RBAC denied for role: &quot; + request.getRole());&#10;            return new AgentResponse(&quot;error&quot;, &quot;Access denied&quot;, List.of(&quot;RBAC check&quot;), new ArrayList&lt;&gt;(), auditId, null, List.of(&quot;Insufficient permissions&quot;));&#10;        }&#10;&#10;        // Step 2: Mock intent parsing and tool invocation&#10;        List&lt;String&gt; steps = new ArrayList&lt;&gt;();&#10;        steps.add(&quot;Parsed request&quot;);&#10;        List&lt;ToolInvocation&gt; toolCalls = new ArrayList&lt;&gt;();&#10;&#10;        if (request.getText().toLowerCase().contains(&quot;count&quot;)) {&#10;            ToolInvocation invocation = mcpLeader.invokeTool(&quot;getEmployeeCount&quot;, Map.of());&#10;            toolCalls.add(invocation);&#10;            steps.add(&quot;Invoked getEmployeeCount tool&quot;);&#10;        } else if (request.getText().toLowerCase().contains(&quot;recognize&quot;)) {&#10;            Map&lt;String, Object&gt; input = Map.of(&#10;                &quot;sender&quot;, request.getActor(),&#10;                &quot;recipient&quot;, &quot;someone@example.com&quot;, // mock&#10;                &quot;message&quot;, request.getText()&#10;            );&#10;            ToolInvocation invocation = mcpLeader.invokeTool(&quot;sendRecognition&quot;, input);&#10;            toolCalls.add(invocation);&#10;            steps.add(&quot;Invoked sendRecognition tool&quot;);&#10;        } else {&#10;            steps.add(&quot;No matching tool found&quot;);&#10;        }&#10;&#10;        // Step 3: Audit&#10;        String auditId = auditLogService.log(request.getActor(), &quot;AGENT_EXECUTE_SUCCESS&quot;, &quot;Executed with &quot; + toolCalls.size() + &quot; tool calls&quot;);&#10;&#10;        // Step 4: Build response&#10;        return new AgentResponse(&quot;ok&quot;, &quot;Execution completed&quot;, steps, toolCalls, auditId, null, new ArrayList&lt;&gt;());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/AgentRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/AgentRequest.java" />
              <option name="updatedContent" value="package com.myteam.agent.core.dto;&#10;&#10;import java.util.Map;&#10;&#10;public class AgentRequest {&#10;    private String actor; // userId or email&#10;    private String role; // e.g., &quot;ADMIN&quot;, &quot;MANAGER&quot;, etc.&#10;    private String text; // user input text&#10;    private String intent; // optional intent&#10;    private Map&lt;String, Object&gt; payload; // additional data&#10;    private String sessionId; // session identifier&#10;    private String preferredChannel; // e.g., &quot;api&quot;, &quot;chat&quot;&#10;    private String correlationId; // for tracing&#10;&#10;    // Constructors&#10;    public AgentRequest() {}&#10;&#10;    public AgentRequest(String actor, String role, String text, String intent, Map&lt;String, Object&gt; payload, String sessionId, String preferredChannel, String correlationId) {&#10;        this.actor = actor;&#10;        this.role = role;&#10;        this.text = text;&#10;        this.intent = intent;&#10;        this.payload = payload;&#10;        this.sessionId = sessionId;&#10;        this.preferredChannel = preferredChannel;&#10;        this.correlationId = correlationId;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public String getActor() { return actor; }&#10;    public void setActor(String actor) { this.actor = actor; }&#10;&#10;    public String getRole() { return role; }&#10;    public void setRole(String role) { this.role = role; }&#10;&#10;    public String getText() { return text; }&#10;    public void setText(String text) { this.text = text; }&#10;&#10;    public String getIntent() { return intent; }&#10;    public void setIntent(String intent) { this.intent = intent; }&#10;&#10;    public Map&lt;String, Object&gt; getPayload() { return payload; }&#10;    public void setPayload(Map&lt;String, Object&gt; payload) { this.payload = payload; }&#10;&#10;    public String getSessionId() { return sessionId; }&#10;    public void setSessionId(String sessionId) { this.sessionId = sessionId; }&#10;&#10;    public String getPreferredChannel() { return preferredChannel; }&#10;    public void setPreferredChannel(String preferredChannel) { this.preferredChannel = preferredChannel; }&#10;&#10;    public String getCorrelationId() { return correlationId; }&#10;    public void setCorrelationId(String correlationId) { this.correlationId = correlationId; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/AgentResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/AgentResponse.java" />
              <option name="updatedContent" value="package com.myteam.agent.core.dto;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public class AgentResponse {&#10;    private String status; // &quot;ok&quot; or &quot;error&quot;&#10;    private String message; // human-readable message&#10;    private List&lt;String&gt; steps; // list of steps taken&#10;    private List&lt;ToolInvocation&gt; toolCalls; // list of tool invocations&#10;    private String auditId; // audit log ID&#10;    private Object data; // any additional data&#10;    private List&lt;String&gt; errors; // list of errors if any&#10;&#10;    // Constructors&#10;    public AgentResponse() {}&#10;&#10;    public AgentResponse(String status, String message, List&lt;String&gt; steps, List&lt;ToolInvocation&gt; toolCalls, String auditId, Object data, List&lt;String&gt; errors) {&#10;        this.status = status;&#10;        this.message = message;&#10;        this.steps = steps;&#10;        this.toolCalls = toolCalls;&#10;        this.auditId = auditId;&#10;        this.data = data;&#10;        this.errors = errors;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public String getStatus() { return status; }&#10;    public void setStatus(String status) { this.status = status; }&#10;&#10;    public String getMessage() { return message; }&#10;    public void setMessage(String message) { this.message = message; }&#10;&#10;    public List&lt;String&gt; getSteps() { return steps; }&#10;    public void setSteps(List&lt;String&gt; steps) { this.steps = steps; }&#10;&#10;    public List&lt;ToolInvocation&gt; getToolCalls() { return toolCalls; }&#10;    public void setToolCalls(List&lt;ToolInvocation&gt; toolCalls) { this.toolCalls = toolCalls; }&#10;&#10;    public String getAuditId() { return auditId; }&#10;    public void setAuditId(String auditId) { this.auditId = auditId; }&#10;&#10;    public Object getData() { return data; }&#10;    public void setData(Object data) { this.data = data; }&#10;&#10;    public List&lt;String&gt; getErrors() { return errors; }&#10;    public void setErrors(List&lt;String&gt; errors) { this.errors = errors; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/ToolInvocation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/dto/ToolInvocation.java" />
              <option name="updatedContent" value="package com.myteam.agent.core.dto;&#10;&#10;import java.util.Map;&#10;&#10;public class ToolInvocation {&#10;    private String toolName;&#10;    private Map&lt;String, Object&gt; input;&#10;    private Map&lt;String, Object&gt; output;&#10;    private long durationMs;&#10;    private boolean success;&#10;&#10;    // Constructors&#10;    public ToolInvocation() {}&#10;&#10;    public ToolInvocation(String toolName, Map&lt;String, Object&gt; input, Map&lt;String, Object&gt; output, long durationMs, boolean success) {&#10;        this.toolName = toolName;&#10;        this.input = input;&#10;        this.output = output;&#10;        this.durationMs = durationMs;&#10;        this.success = success;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public String getToolName() { return toolName; }&#10;    public void setToolName(String toolName) { this.toolName = toolName; }&#10;&#10;    public Map&lt;String, Object&gt; getInput() { return input; }&#10;    public void setInput(Map&lt;String, Object&gt; input) { this.input = input; }&#10;&#10;    public Map&lt;String, Object&gt; getOutput() { return output; }&#10;    public void setOutput(Map&lt;String, Object&gt; output) { this.output = output; }&#10;&#10;    public long getDurationMs() { return durationMs; }&#10;    public void setDurationMs(long durationMs) { this.durationMs = durationMs; }&#10;&#10;    public boolean isSuccess() { return success; }&#10;    public void setSuccess(boolean success) { this.success = success; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/policy/RbacPolicyMapper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/policy/RbacPolicyMapper.java" />
              <option name="updatedContent" value="package com.myteam.agent.core.policy;&#10;&#10;import java.util.Set;&#10;&#10;public class RbacPolicyMapper {&#10;&#10;    // For now, allow all roles to execute agent requests&#10;    // In future phases, this can be refined based on intent or tool&#10;    public static boolean canExecuteAgent(String role) {&#10;        return Set.of(&quot;ADMIN&quot;, &quot;MANAGER&quot;, &quot;TEAMLEAD&quot;, &quot;EMPLOYEE&quot;).contains(role.toUpperCase());&#10;    }&#10;&#10;    // Placeholder for future tool-specific permissions&#10;    public static boolean canUseTool(String role, String toolName) {&#10;        // For mock tools, allow all&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/policy/RbacRoles.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/core/policy/RbacRoles.java" />
              <option name="updatedContent" value="package com.myteam.agent.core.policy;&#10;&#10;public enum RbacRoles {&#10;    ADMIN,&#10;    MANAGER,&#10;    TEAMLEAD,&#10;    EMPLOYEE&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/mcp/McpLeader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/mcp/McpLeader.java" />
              <option name="updatedContent" value="package com.myteam.agent.mcp;&#10;&#10;import com.myteam.agent.core.dto.ToolInvocation;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public interface McpLeader {&#10;&#10;    // Register a tool&#10;    void registerTool(String toolName, ToolFunction toolFunction);&#10;&#10;    // Invoke a tool&#10;    ToolInvocation invokeTool(String toolName, Map&lt;String, Object&gt; input);&#10;&#10;    // List available tools&#10;    List&lt;String&gt; listTools();&#10;&#10;    // Functional interface for tool functions&#10;    @FunctionalInterface&#10;    interface ToolFunction {&#10;        Map&lt;String, Object&gt; execute(Map&lt;String, Object&gt; input);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/myteam/agent/mcp/McpLeaderImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/myteam/agent/mcp/McpLeaderImpl.java" />
              <option name="updatedContent" value="package com.myteam.agent.mcp;&#10;&#10;import com.myteam.agent.core.dto.ToolInvocation;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Component&#10;public class McpLeaderImpl implements McpLeader {&#10;&#10;    private final Map&lt;String, ToolFunction&gt; tools = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    // Constructor to register mock tools&#10;    public McpLeaderImpl() {&#10;        registerTool(&quot;getEmployeeCount&quot;, input -&gt; {&#10;            // Mock: return a fixed count&#10;            Map&lt;String, Object&gt; output = new HashMap&lt;&gt;();&#10;            output.put(&quot;count&quot;, 42);&#10;            return output;&#10;        });&#10;&#10;        registerTool(&quot;sendRecognition&quot;, input -&gt; {&#10;            // Mock: simulate sending recognition&#10;            String sender = (String) input.get(&quot;sender&quot;);&#10;            String recipient = (String) input.get(&quot;recipient&quot;);&#10;            String message = (String) input.get(&quot;message&quot;);&#10;            Map&lt;String, Object&gt; output = new HashMap&lt;&gt;();&#10;            output.put(&quot;status&quot;, &quot;sent&quot;);&#10;            output.put(&quot;id&quot;, &quot;mock-recog-&quot; + System.currentTimeMillis());&#10;            return output;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void registerTool(String toolName, ToolFunction toolFunction) {&#10;        tools.put(toolName, toolFunction);&#10;    }&#10;&#10;    @Override&#10;    public ToolInvocation invokeTool(String toolName, Map&lt;String, Object&gt; input) {&#10;        ToolFunction tool = tools.get(toolName);&#10;        if (tool == null) {&#10;            return new ToolInvocation(toolName, input, Map.of(&quot;error&quot;, &quot;Tool not found&quot;), 0, false);&#10;        }&#10;        long start = System.currentTimeMillis();&#10;        try {&#10;            Map&lt;String, Object&gt; output = tool.execute(input);&#10;            long duration = System.currentTimeMillis() - start;&#10;            return new ToolInvocation(toolName, input, output, duration, true);&#10;        } catch (Exception e) {&#10;            long duration = System.currentTimeMillis() - start;&#10;            return new ToolInvocation(toolName, input, Map.of(&quot;error&quot;, e.getMessage()), duration, false);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;String&gt; listTools() {&#10;        return List.copyOf(tools.keySet());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/controller/AdminV1Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/controller/AdminV1Controller.java" />
              <option name="originalContent" value="package org.example.controller;&#10;&#10;import org.example.service.StagingImportService;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/admin&quot;)&#10;public class AdminV1Controller {&#10;&#10;    private final StagingImportService stagingImportService;&#10;    private final boolean devEnabled;&#10;&#10;    public AdminV1Controller(StagingImportService stagingImportService, @Value(&quot;${app.dev.enabled:false}&quot;) boolean devEnabled) {&#10;        this.stagingImportService = stagingImportService;&#10;        this.devEnabled = devEnabled;&#10;    }&#10;&#10;    @PostMapping(&quot;/imports&quot;)&#10;    public ResponseEntity&lt;?&gt; startImport(@RequestParam MultipartFile file) {&#10;        if (!devEnabled) return ResponseEntity.status(403).body(Map.of(&quot;error&quot;, &quot;admin import disabled&quot;));&#10;        try {&#10;            Map&lt;String, Object&gt; res = stagingImportService.startImportViaCopyAsync(file, file.getOriginalFilename());&#10;            return ResponseEntity.accepted().body(res);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(500).body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/imports/{jobId}&quot;)&#10;    public ResponseEntity&lt;?&gt; getImportStatus(@PathVariable Long jobId) {&#10;        if (!devEnabled) return ResponseEntity.status(403).body(Map.of(&quot;error&quot;, &quot;admin import disabled&quot;));&#10;        try {&#10;            Map&lt;String, Object&gt; status = stagingImportService.getImportJobStatus(jobId);&#10;            return ResponseEntity.ok(status);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(500).body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.controller;&#10;&#10;// Deprecated stub. Use AdminController (/admin) for admin endpoints.&#10;public class AdminV1Controller {&#10;    // deprecated&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/controller/RecognitionV1Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/controller/RecognitionV1Controller.java" />
              <option name="originalContent" value="package org.example.controller;&#10;&#10;import org.example.dto.RecognitionResponse;&#10;import org.example.dto.StatusUpdateRequest;&#10;import org.example.model.Recognition;&#10;import org.example.model.Employee;&#10;import org.example.repository.EmployeeRepository;&#10;import org.example.repository.RecognitionRepository;&#10;import org.example.service.RecognitionCsvExporter;&#10;import org.example.util.EntityMapper;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;&#10;&#10;import java.io.OutputStream;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/recognitions&quot;)&#10;public class RecognitionV1Controller {&#10;&#10;    private final RecognitionRepository recognitionRepository;&#10;    private final EmployeeRepository employeeRepository;&#10;    private final RecognitionCsvExporter csvExporter;&#10;&#10;    public RecognitionV1Controller(RecognitionRepository recognitionRepository, EmployeeRepository employeeRepository, RecognitionCsvExporter csvExporter) {&#10;        this.recognitionRepository = recognitionRepository;&#10;        this.employeeRepository = employeeRepository;&#10;        this.csvExporter = csvExporter;&#10;    }&#10;&#10;    @GetMapping&#10;    public Page&lt;RecognitionResponse&gt; list(@RequestParam(defaultValue = &quot;0&quot;) int page,&#10;                                         @RequestParam(defaultValue = &quot;20&quot;) int size,&#10;                                         @RequestParam(required = false) Long senderId,&#10;                                         @RequestParam(required = false) UUID senderUuid,&#10;                                         @RequestParam(required = false) Long recipientId,&#10;                                         @RequestParam(required = false) UUID recipientUuid) {&#10;        Pageable p = PageRequest.of(page, size);&#10;&#10;        // prefer uuid if provided&#10;        if (senderUuid != null) {&#10;            Optional&lt;java.util.UUID&gt; su = Optional.of(senderUuid);&#10;            List&lt;Employee&gt; senders = employeeRepository.findAllByUuidIn(List.of(senderUuid)).stream().collect(Collectors.toList());&#10;            if (!senders.isEmpty()) {&#10;                return recognitionRepository.findAllBySenderId(senders.get(0).getId(), p).map(EntityMapper::toRecognitionResponse);&#10;            }&#10;        }&#10;        if (recipientUuid != null) {&#10;            List&lt;Employee&gt; recs = employeeRepository.findAllByUuidIn(List.of(recipientUuid)).stream().collect(Collectors.toList());&#10;            if (!recs.isEmpty()) {&#10;                return recognitionRepository.findAllByRecipientId(recs.get(0).getId(), p).map(EntityMapper::toRecognitionResponse);&#10;            }&#10;        }&#10;&#10;        if (senderId != null) return recognitionRepository.findAllBySenderId(senderId, p).map(EntityMapper::toRecognitionResponse);&#10;        if (recipientId != null) return recognitionRepository.findAllByRecipientId(recipientId, p).map(EntityMapper::toRecognitionResponse);&#10;&#10;        return recognitionRepository.findAllWithRelations(p).map(EntityMapper::toRecognitionResponse);&#10;    }&#10;&#10;    @GetMapping(&quot;/{uuid}&quot;)&#10;    public ResponseEntity&lt;?&gt; getByUuid(@PathVariable UUID uuid) {&#10;        Optional&lt;Recognition&gt; r = recognitionRepository.findByUuidWithRelations(uuid);&#10;        return r.map(rec -&gt; ResponseEntity.ok(EntityMapper.toRecognitionResponse(rec))).orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    // backward-compatible: allow id query&#10;    @GetMapping(params = &quot;id&quot;)&#10;    public ResponseEntity&lt;?&gt; getById(@RequestParam Long id) {&#10;        Optional&lt;Recognition&gt; r = recognitionRepository.findByIdWithRelations(id);&#10;        return r.map(rec -&gt; ResponseEntity.ok(EntityMapper.toRecognitionResponse(rec))).orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PatchMapping(&quot;/{uuid}/status&quot;)&#10;    public ResponseEntity&lt;?&gt; updateStatus(@PathVariable UUID uuid, @RequestBody StatusUpdateRequest req) {&#10;        Optional&lt;Recognition&gt; opt = recognitionRepository.findByUuidWithRelations(uuid);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        Recognition r = opt.get();&#10;        String desired = req != null ? req.status : null;&#10;        if (desired == null) return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;status is required&quot;));&#10;        String upper = desired.toUpperCase();&#10;        if (&quot;APPROVED&quot;.equals(upper)) {&#10;            r.setApprovalStatus(&quot;APPROVED&quot;);&#10;            r.setRejectionReason(null); // clear rejectionReason on approve&#10;        } else if (&quot;REJECTED&quot;.equals(upper)) {&#10;            if (req.rejectionReason == null || req.rejectionReason.isBlank()) return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;rejectionReason required for REJECTED status&quot;));&#10;            r.setApprovalStatus(&quot;REJECTED&quot;);&#10;            r.setRejectionReason(req.rejectionReason);&#10;        } else if (&quot;PENDING&quot;.equals(upper)) {&#10;            r.setApprovalStatus(&quot;PENDING&quot;);&#10;        } else {&#10;            return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;unknown status&quot;));&#10;        }&#10;        recognitionRepository.save(r);&#10;        Recognition reloaded = recognitionRepository.findByUuidWithRelations(r.getUuid()).orElse(r);&#10;        return ResponseEntity.ok(EntityMapper.toRecognitionResponse(reloaded));&#10;    }&#10;&#10;    @GetMapping(&quot;/export&quot;)&#10;    public ResponseEntity&lt;?&gt; export(@RequestParam(defaultValue = &quot;json&quot;) String format,&#10;                                    @RequestParam(defaultValue = &quot;false&quot;) boolean stream,&#10;                                    @RequestParam(required = false) UUID recipientUuid,&#10;                                    @RequestParam(required = false) Long recipientId) throws Exception {&#10;        List&lt;Recognition&gt; list;&#10;        if (recipientUuid != null) {&#10;            List&lt;Employee&gt; recs = employeeRepository.findAllByUuidIn(List.of(recipientUuid));&#10;            if (!recs.isEmpty()) list = recognitionRepository.findAllByRecipientId(recs.get(0).getId(), Pageable.unpaged()).getContent();&#10;            else list = List.of();&#10;        } else if (recipientId != null) {&#10;            list = recognitionRepository.findAllByRecipientId(recipientId, Pageable.unpaged()).getContent();&#10;        } else {&#10;            list = recognitionRepository.findAllWithRelations(Pageable.unpaged()).getContent();&#10;        }&#10;&#10;        if (&quot;csv&quot;.equalsIgnoreCase(format)) {&#10;            if (stream) {&#10;                StreamingResponseBody s = (OutputStream os) -&gt; {&#10;                    try {&#10;                        csvExporter.exportToStream(os, list);&#10;                    } catch (Exception ex) {&#10;                        throw new RuntimeException(ex);&#10;                    }&#10;                };&#10;                return ResponseEntity.ok()&#10;                        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=recognitions.csv&quot;)&#10;                        .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))&#10;                        .body(s);&#10;            } else {&#10;                byte[] bytes = csvExporter.export(list);&#10;                return ResponseEntity.ok()&#10;                        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=recognitions.csv&quot;)&#10;                        .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))&#10;                        .body(bytes);&#10;            }&#10;        } else {&#10;            List&lt;RecognitionResponse&gt; resp = list.stream().map(EntityMapper::toRecognitionResponse).collect(Collectors.toList());&#10;            return ResponseEntity.ok(resp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example.controller;&#10;&#10;// This controller was a v1 prototype and is now deprecated. The canonical endpoints are served by `RecognitionController` at `/recognitions`.&#10;// Kept intentionally empty to avoid duplicate bean registration.&#10;&#10;public class RecognitionV1Controller {&#10;    // deprecated stub&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>