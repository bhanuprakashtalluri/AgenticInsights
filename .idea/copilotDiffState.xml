<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/Main.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/Main.md" />
              <option name="updatedContent" value="# Main.java&#10;&#10;This file contains the main entry point for the Spring Boot application.&#10;&#10;```java&#10;package org.example;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;import org.springframework.cache.annotation.EnableCaching;&#10;&#10;@SpringBootApplication&#10;@EnableScheduling&#10;@EnableCaching&#10;public class Main {&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(Main.class, args);&#10;    }&#10;}&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/myteam-ui/src/features/RecognitionManagement.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/myteam-ui/src/features/RecognitionManagement.tsx" />
              <option name="originalContent" value="import React, { useEffect, useState } from 'react';&#10;import axios from 'axios';&#10;&#10;const PAGE_SIZE_OPTIONS = [5, 10, 20, 50, 100];&#10;&#10;const RecognitionManagement: React.FC = () =&gt; {&#10;  const [recognitions, setRecognitions] = useState&lt;any[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState('');&#10;  const [page, setPage] = useState(0);&#10;  const [pageSize, setPageSize] = useState(20);&#10;  const [totalPages, setTotalPages] = useState(1);&#10;  const [sortField, setSortField] = useState('date');&#10;  const [sortOrder, setSortOrder] = useState&lt;'asc' | 'desc'&gt;('desc');&#10;  const [allRecognitions, setAllRecognitions] = useState&lt;any[]&gt;([]); // Store all recognitions if backend returns array&#10;&#10;  // Search state&#10;  const [search, setSearch] = useState('');&#10;  // Create form state&#10;  const [createForm, setCreateForm] = useState({&#10;    recognitionTypeName: '',&#10;    category: '',&#10;    level: '',&#10;    awardPoints: '',&#10;    senderName: '',&#10;    recipientName: '',&#10;    message: '',&#10;  });&#10;  const [creating, setCreating] = useState(false);&#10;  const [createSuccess, setCreateSuccess] = useState('');&#10;  const [createError, setCreateError] = useState('');&#10;&#10;  const sortableColumns = [&#10;    { key: 'id', label: 'ID' },&#10;    { key: 'recognitionTypeName', label: 'Type' },&#10;    { key: 'category', label: 'Category' },&#10;    { key: 'level', label: 'Level' },&#10;    { key: 'awardPoints', label: 'Points' },&#10;    { key: 'senderName', label: 'Sender Name' },&#10;    { key: 'recipientName', label: 'Recipient Name' },&#10;    { key: 'message', label: 'Message' },&#10;    { key: 'sentAt', label: 'Date' },&#10;    { key: 'approvalStatus', label: 'Approval Status' },&#10;    { key: 'rejectionReason', label: 'Rejection Reason' },&#10;  ];&#10;&#10;  const sortRecognitions = (data: any[]) =&gt; {&#10;    return [...data].sort((a, b) =&gt; {&#10;      let aVal = a[sortField];&#10;      let bVal = b[sortField];&#10;      // Special handling for date&#10;      if (sortField === 'sentAt') {&#10;        aVal = a.sentAt || a.createdAt || 0;&#10;        bVal = b.sentAt || b.createdAt || 0;&#10;      }&#10;      // Handle null/undefined&#10;      if (aVal === undefined || aVal === null) aVal = '';&#10;      if (bVal === undefined || bVal === null) bVal = '';&#10;      // Numeric sort if both are numbers&#10;      if (!isNaN(Number(aVal)) &amp;&amp; !isNaN(Number(bVal))) {&#10;        aVal = Number(aVal);&#10;        bVal = Number(bVal);&#10;      } else {&#10;        aVal = String(aVal).toLowerCase();&#10;        bVal = String(bVal).toLowerCase();&#10;      }&#10;      if (aVal &lt; bVal) return sortOrder === 'asc' ? -1 : 1;&#10;      if (aVal &gt; bVal) return sortOrder === 'asc' ? 1 : -1;&#10;      return 0;&#10;    });&#10;  };&#10;&#10;  const fetchRecognitions = async (newPage = page, newPageSize = pageSize) =&gt; {&#10;    setLoading(true);&#10;    setError('');&#10;    try {&#10;      if (newPageSize &lt; 1) newPageSize = 1;&#10;      if (newPageSize &gt; 100) newPageSize = 100;&#10;      const res = await axios.get(`/recognitions?page=${newPage}&amp;size=${newPageSize}`);&#10;      let items;&#10;      let total = 1;&#10;      if (Array.isArray(res.data)) {&#10;        // Frontend paging for array response&#10;        setAllRecognitions(res.data);&#10;        total = Math.max(1, Math.ceil(res.data.length / newPageSize));&#10;        items = sortRecognitions(res.data).slice(newPage * newPageSize, (newPage + 1) * newPageSize);&#10;      } else {&#10;        items = sortRecognitions(res.data.content || []);&#10;        total = res.data.totalPages || 1;&#10;        setAllRecognitions([]); // Clear if backend is paginated&#10;      }&#10;      setRecognitions(items);&#10;      setTotalPages(total);&#10;      setPage(newPage);&#10;      setPageSize(newPageSize);&#10;    } catch (err: any) {&#10;      setError('Failed to fetch recognitions from the backend. Please check if the backend is running and the endpoint is correct.');&#10;      setRecognitions([]);&#10;      setTotalPages(1);&#10;      setAllRecognitions([]);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  // Helper for frontend paging&#10;  const updateFrontendPage = (newPage: number, newPageSize: number) =&gt; {&#10;    const total = Math.max(1, Math.ceil(allRecognitions.length / newPageSize));&#10;    const items = sortRecognitions(allRecognitions).slice(newPage * newPageSize, (newPage + 1) * newPageSize);&#10;    setRecognitions(items);&#10;    setTotalPages(total);&#10;    setPage(newPage);&#10;    setPageSize(newPageSize);&#10;  };&#10;&#10;  // Initial load only&#10;  useEffect(() =&gt; {&#10;    const loadRecognitions = async () =&gt; {&#10;      setLoading(true);&#10;      setError('');&#10;      try {&#10;        const res = await axios.get(`/recognitions?page=0&amp;size=10000`); // Get all for frontend paging&#10;        if (Array.isArray(res.data)) {&#10;          setAllRecognitions(res.data);&#10;          updateFrontendPage(0, pageSize);&#10;        } else {&#10;          setAllRecognitions([]);&#10;          setRecognitions(sortRecognitions(res.data.content || []));&#10;          setTotalPages(res.data.totalPages || 1);&#10;          setPage(res.data.pageable?.pageNumber ?? 0);&#10;          setPageSize(res.data.pageable?.pageSize ?? pageSize);&#10;        }&#10;      } catch (err: any) {&#10;        setError('Failed to fetch recognitions from the backend. Please check if the backend is running and the endpoint is correct.');&#10;        setRecognitions([]);&#10;        setTotalPages(1);&#10;        setAllRecognitions([]);&#10;      } finally {&#10;        setLoading(false);&#10;      }&#10;    };&#10;    loadRecognitions();&#10;    // eslint-disable-next-line&#10;  }, []);&#10;&#10;  // Ensure table updates on sort/page change if recognitions are loaded&#10;  useEffect(() =&gt; {&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(page, pageSize);&#10;    }&#10;    // eslint-disable-next-line&#10;  }, [sortField, sortOrder, page, pageSize, allRecognitions]);&#10;&#10;  // Page change handler&#10;  const handlePageChange = (newPage: number) =&gt; {&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(newPage, pageSize);&#10;    } else {&#10;      fetchRecognitions(newPage, pageSize);&#10;    }&#10;  };&#10;&#10;  // Page size change handler&#10;  const handlePageSizeChange = (e: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {&#10;    const newSize = parseInt(e.target.value, 10);&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(0, newSize);&#10;    } else {&#10;      fetchRecognitions(0, newSize);&#10;    }&#10;  };&#10;&#10;  // Filter recognitions by search query (searches allRecognitions if search is present)&#10;  const getFilteredRecognitions = () =&gt; {&#10;    const source = search.trim() ? allRecognitions : recognitions;&#10;    if (!search.trim()) return recognitions;&#10;    const q = search.trim().toLowerCase();&#10;    return source.filter(rec =&gt;&#10;      [rec.id, rec.recognitionTypeName, rec.category, rec.level, rec.awardPoints, rec.senderName, rec.recipientName, rec.message, rec.approvalStatus, rec.rejectionReason]&#10;        .map(val =&gt; (val !== undefined &amp;&amp; val !== null ? String(val).toLowerCase() : ''))&#10;        .some(val =&gt; val.includes(q))&#10;    );&#10;  };&#10;&#10;  // Create recognition handler&#10;  const handleCreateInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt; | React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {&#10;    setCreateForm({ ...createForm, [e.target.name]: e.target.value });&#10;  };&#10;  const handleCreate = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    setCreating(true);&#10;    setCreateError('');&#10;    setCreateSuccess('');&#10;    try {&#10;      // You may need to map names to IDs/UUIDs in a real app&#10;      await axios.post('/recognitions', {&#10;        recognitionTypeName: createForm.recognitionTypeName,&#10;        category: createForm.category,&#10;        level: createForm.level,&#10;        awardPoints: Number(createForm.awardPoints),&#10;        senderName: createForm.senderName,&#10;        recipientName: createForm.recipientName,&#10;        message: createForm.message,&#10;      });&#10;      setCreateSuccess('Recognition created successfully');&#10;      setCreateForm({ recognitionTypeName: '', category: '', level: '', awardPoints: '', senderName: '', recipientName: '', message: '' });&#10;      // Reload recognitions&#10;      setTimeout(() =&gt; window.location.reload(), 500); // quick reload for demo&#10;    } catch (err: any) {&#10;      setCreateError('Failed to create recognition');&#10;    } finally {&#10;      setCreating(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div style={{ width: '100%', minHeight: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center' }}&gt;&#10;      &lt;h2 style={{ textAlign: 'center', marginBottom: 24, fontSize: '1.7rem', fontWeight: 600 }}&gt;Recognition Management&lt;/h2&gt;&#10;      {error &amp;&amp; &lt;div style={{ color: 'red', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{error}&lt;/div&gt;}&#10;      {createError &amp;&amp; &lt;div style={{ color: 'red', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{createError}&lt;/div&gt;}&#10;      {createSuccess &amp;&amp; &lt;div style={{ color: 'green', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{createSuccess}&lt;/div&gt;}&#10;      &lt;form onSubmit={handleCreate} style={{ width: '100%', display: 'flex', flexWrap: 'wrap', gap: 10, marginBottom: 20, alignItems: 'center', background: '#fff', padding: 10, borderRadius: 8, boxShadow: '0 2px 8px #e0e0e0', fontSize: '0.7rem', justifyContent: 'center' }}&gt;&#10;        &lt;input name=&quot;recognitionTypeName&quot; placeholder=&quot;Type&quot; value={createForm.recognitionTypeName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;category&quot; placeholder=&quot;Category&quot; value={createForm.category} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;level&quot; placeholder=&quot;Level&quot; value={createForm.level} onChange={handleCreateInputChange} style={{ flex: '1 1 70px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;awardPoints&quot; placeholder=&quot;Points&quot; value={createForm.awardPoints} onChange={handleCreateInputChange} style={{ flex: '1 1 70px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;senderName&quot; placeholder=&quot;Sender Name&quot; value={createForm.senderName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;recipientName&quot; placeholder=&quot;Recipient Name&quot; value={createForm.recipientName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;message&quot; placeholder=&quot;Message&quot; value={createForm.message} onChange={handleCreateInputChange} required style={{ flex: '2 1 160px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;div style={{ flex: '1 1 100%', display: 'flex', justifyContent: 'center', gap: 10 }}&gt;&#10;          &lt;button type=&quot;submit&quot; disabled={creating} style={{ background: '#1976d2', color: '#fff', border: 'none', borderRadius: 6, padding: '7px 14px', fontSize: '0.7rem', cursor: 'pointer', fontWeight: 500 }}&gt;Create&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;      &lt;div style={{ marginBottom: 12, display: 'flex', justifyContent: 'flex-end', alignItems: 'center', gap: 8, width: '100%' }}&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          value={search}&#10;          onChange={e =&gt; setSearch(e.target.value)}&#10;          placeholder=&quot;Search recognitions...&quot;&#10;          style={{ padding: '7px 12px', fontSize: '0.8rem', borderRadius: 6, border: '1px solid #ccc', width: 220 }}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div style={{ marginBottom: 14, display: 'flex', alignItems: 'center', gap: 14, fontSize: '0.7rem', justifyContent: 'center', width: '100%' }}&gt;&#10;        &lt;label&gt;Page Size:&lt;/label&gt;&#10;        &lt;select value={pageSize} onChange={handlePageSizeChange} style={{ padding: 5, fontSize: '0.7rem' }}&gt;&#10;          {PAGE_SIZE_OPTIONS.map(size =&gt; (&#10;            &lt;option key={size} value={size}&gt;{size}&lt;/option&gt;&#10;          ))}&#10;        &lt;/select&gt;&#10;        &lt;span style={{ marginLeft: 16 }}&gt;&#10;          Page: &lt;b&gt;{page + 1}&lt;/b&gt; / &lt;b&gt;{totalPages}&lt;/b&gt;&#10;        &lt;/span&gt;&#10;        &lt;div style={{ display: 'flex', gap: 8 }}&gt;&#10;          &lt;button onClick={() =&gt; handlePageChange(page - 1)} disabled={page &lt;= 0} style={{ padding: '6px 12px', fontSize: '0.7rem', background: '#eee', border: '1px solid #ccc', borderRadius: 6, cursor: page &lt;= 0 ? 'not-allowed' : 'pointer' }}&gt;Prev&lt;/button&gt;&#10;          &lt;button onClick={() =&gt; handlePageChange(page + 1)} disabled={page + 1 &gt;= totalPages} style={{ padding: '6px 12px', fontSize: '0.7rem', background: '#eee', border: '1px solid #ccc', borderRadius: 6, cursor: page + 1 &gt;= totalPages ? 'not-allowed' : 'pointer' }}&gt;Next&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;table style={{ width: '100%', fontSize: '0.7rem', background: '#fff', borderRadius: 8, boxShadow: '0 2px 8px #e0e0e0' }}&gt;&#10;        &lt;thead&gt;&#10;          &lt;tr style={{ background: '#8da1bd' }}&gt;&#10;            {sortableColumns.map(col =&gt; (&#10;              &lt;th&#10;                key={col.key}&#10;                style={{ padding: 8, cursor: 'pointer', userSelect: 'none', whiteSpace: 'nowrap' }}&#10;                onClick={() =&gt; {&#10;                  if (sortField === col.key) {&#10;                    setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');&#10;                  } else {&#10;                    setSortField(col.key);&#10;                    setSortOrder('asc');&#10;                  }&#10;                }}&#10;              &gt;&#10;                {col.label}&#10;                &lt;span style={{ marginLeft: 4, color: sortField === col.key ? '#050505' : '#bbb', fontWeight: 700, fontSize: '1rem', cursor: 'pointer' }}&gt;&#10;                  {sortField === col.key ? (sortOrder === 'asc' ? '▲' : '▼') : '▲▼'}&#10;                &lt;/span&gt;&#10;              &lt;/th&gt;&#10;            ))}&#10;          &lt;/tr&gt;&#10;        &lt;/thead&gt;&#10;        &lt;tbody&gt;&#10;          {getFilteredRecognitions().map(rec =&gt; (&#10;            &lt;tr key={rec.id} style={{ background: '#fff' }}&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.id}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.recognitionTypeName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.category}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.level || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.awardPoints}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.senderName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.recipientName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.message || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.sentAt ? new Date(rec.sentAt * 1000).toLocaleDateString() : '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.approvalStatus || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.rejectionReason || '-'}&lt;/td&gt;&#10;            &lt;/tr&gt;&#10;          ))}&#10;        &lt;/tbody&gt;&#10;      &lt;/table&gt;&#10;      {!loading &amp;&amp; !error &amp;&amp; getFilteredRecognitions().length === 0 &amp;&amp; (&#10;        &lt;div style={{ fontSize: '0.7rem', color: '#888', marginTop: 12 }}&gt;No recognitions found.&lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default RecognitionManagement;&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useState } from 'react';&#10;import axios from 'axios';&#10;&#10;const PAGE_SIZE_OPTIONS = [5, 10, 20, 50, 100];&#10;&#10;const RecognitionManagement: React.FC = () =&gt; {&#10;  const [recognitions, setRecognitions] = useState&lt;any[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [error, setError] = useState('');&#10;  const [page, setPage] = useState(0);&#10;  const [pageSize, setPageSize] = useState(20);&#10;  const [totalPages, setTotalPages] = useState(1);&#10;  const [sortField, setSortField] = useState('date');&#10;  const [sortOrder, setSortOrder] = useState&lt;'asc' | 'desc'&gt;('desc');&#10;  const [allRecognitions, setAllRecognitions] = useState&lt;any[]&gt;([]); // Store all recognitions if backend returns array&#10;&#10;  // Search state&#10;  const [search, setSearch] = useState('');&#10;  // Create form state&#10;  const [createForm, setCreateForm] = useState({&#10;    recognitionTypeName: '',&#10;    category: '',&#10;    level: '',&#10;    awardPoints: '',&#10;    senderName: '',&#10;    recipientName: '',&#10;    message: '',&#10;  });&#10;  const [creating, setCreating] = useState(false);&#10;  const [createSuccess, setCreateSuccess] = useState('');&#10;  const [createError, setCreateError] = useState('');&#10;&#10;  const sortableColumns = [&#10;    { key: 'id', label: 'ID' },&#10;    { key: 'recognitionTypeName', label: 'Type' },&#10;    { key: 'category', label: 'Category' },&#10;    { key: 'level', label: 'Level' },&#10;    { key: 'awardPoints', label: 'Points' },&#10;    { key: 'senderName', label: 'Sender Name' },&#10;    { key: 'recipientName', label: 'Recipient Name' },&#10;    { key: 'message', label: 'Message' },&#10;    { key: 'sentAt', label: 'Date' },&#10;    { key: 'approvalStatus', label: 'Approval Status' },&#10;    { key: 'rejectionReason', label: 'Rejection Reason' },&#10;  ];&#10;&#10;  const sortRecognitions = (data: any[]) =&gt; {&#10;    return [...data].sort((a, b) =&gt; {&#10;      let aVal = a[sortField];&#10;      let bVal = b[sortField];&#10;      // Special handling for date&#10;      if (sortField === 'sentAt') {&#10;        aVal = a.sentAt || a.createdAt || 0;&#10;        bVal = b.sentAt || b.createdAt || 0;&#10;      }&#10;      // Handle null/undefined&#10;      if (aVal === undefined || aVal === null) aVal = '';&#10;      if (bVal === undefined || bVal === null) bVal = '';&#10;      // Numeric sort if both are numbers&#10;      if (!isNaN(Number(aVal)) &amp;&amp; !isNaN(Number(bVal))) {&#10;        aVal = Number(aVal);&#10;        bVal = Number(bVal);&#10;      } else {&#10;        aVal = String(aVal).toLowerCase();&#10;        bVal = String(bVal).toLowerCase();&#10;      }&#10;      if (aVal &lt; bVal) return sortOrder === 'asc' ? -1 : 1;&#10;      if (aVal &gt; bVal) return sortOrder === 'asc' ? 1 : -1;&#10;      return 0;&#10;    });&#10;  };&#10;&#10;  const fetchRecognitions = async (newPage = page, newPageSize = pageSize) =&gt; {&#10;    setLoading(true);&#10;    setError('');&#10;    try {&#10;      if (newPageSize &lt; 1) newPageSize = 1;&#10;      if (newPageSize &gt; 100) newPageSize = 100;&#10;      const res = await axios.get(`/recognitions?page=${newPage}&amp;size=${newPageSize}`);&#10;      let items;&#10;      let total = 1;&#10;      if (Array.isArray(res.data)) {&#10;        // Frontend paging for array response&#10;        setAllRecognitions(res.data);&#10;        total = Math.max(1, Math.ceil(res.data.length / newPageSize));&#10;        items = sortRecognitions(res.data).slice(newPage * newPageSize, (newPage + 1) * newPageSize);&#10;      } else {&#10;        items = sortRecognitions(res.data.content || []);&#10;        total = res.data.totalPages || 1;&#10;        setAllRecognitions([]); // Clear if backend is paginated&#10;      }&#10;      setRecognitions(items);&#10;      setTotalPages(total);&#10;      setPage(newPage);&#10;      setPageSize(newPageSize);&#10;    } catch (err: any) {&#10;      setError('Failed to fetch recognitions from the backend. Please check if the backend is running and the endpoint is correct.');&#10;      setRecognitions([]);&#10;      setTotalPages(1);&#10;      setAllRecognitions([]);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  // Helper for frontend paging&#10;  const updateFrontendPage = (newPage: number, newPageSize: number) =&gt; {&#10;    const total = Math.max(1, Math.ceil(allRecognitions.length / newPageSize));&#10;    const items = sortRecognitions(allRecognitions).slice(newPage * newPageSize, (newPage + 1) * newPageSize);&#10;    setRecognitions(items);&#10;    setTotalPages(total);&#10;    setPage(newPage);&#10;    setPageSize(newPageSize);&#10;  };&#10;&#10;  // Initial load only&#10;  useEffect(() =&gt; {&#10;    const loadRecognitions = async () =&gt; {&#10;      setLoading(true);&#10;      setError('');&#10;      try {&#10;        const res = await axios.get(`/recognitions?page=0&amp;size=10000`); // Get all for frontend paging&#10;        if (Array.isArray(res.data)) {&#10;          setAllRecognitions(res.data);&#10;          updateFrontendPage(0, pageSize);&#10;        } else {&#10;          setAllRecognitions([]);&#10;          setRecognitions(sortRecognitions(res.data.content || []));&#10;          setTotalPages(res.data.totalPages || 1);&#10;          setPage(res.data.pageable?.pageNumber ?? 0);&#10;          setPageSize(res.data.pageable?.pageSize ?? pageSize);&#10;        }&#10;      } catch (err: any) {&#10;        setError('Failed to fetch recognitions from the backend. Please check if the backend is running and the endpoint is correct.');&#10;        setRecognitions([]);&#10;        setTotalPages(1);&#10;        setAllRecognitions([]);&#10;      } finally {&#10;        setLoading(false);&#10;      }&#10;    };&#10;    loadRecognitions();&#10;    // eslint-disable-next-line&#10;  }, []);&#10;&#10;  // Ensure table updates on sort/page change if recognitions are loaded&#10;  useEffect(() =&gt; {&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(page, pageSize);&#10;    }&#10;    // eslint-disable-next-line&#10;  }, [sortField, sortOrder, page, pageSize, allRecognitions]);&#10;&#10;  // Page change handler&#10;  const handlePageChange = (newPage: number) =&gt; {&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(newPage, pageSize);&#10;    } else {&#10;      fetchRecognitions(newPage, pageSize);&#10;    }&#10;  };&#10;&#10;  // Page size change handler&#10;  const handlePageSizeChange = (e: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {&#10;    const newSize = parseInt(e.target.value, 10);&#10;    if (allRecognitions.length &gt; 0) {&#10;      updateFrontendPage(0, newSize);&#10;    } else {&#10;      fetchRecognitions(0, newSize);&#10;    }&#10;  };&#10;&#10;  // Filter recognitions by search query (searches allRecognitions if search is present)&#10;  const getFilteredRecognitions = () =&gt; {&#10;    const source = search.trim() ? allRecognitions : recognitions;&#10;    if (!search.trim()) return recognitions;&#10;    const q = search.trim().toLowerCase();&#10;    return source.filter(rec =&gt;&#10;      [rec.id, rec.recognitionTypeName, rec.category, rec.level, rec.awardPoints, rec.senderName, rec.recipientName, rec.message, rec.approvalStatus, rec.rejectionReason]&#10;        .map(val =&gt; (val !== undefined &amp;&amp; val !== null ? String(val).toLowerCase() : ''))&#10;        .some(val =&gt; val.includes(q))&#10;    );&#10;  };&#10;&#10;  // Get paged recognitions (applies paging to filtered results)&#10;  const getPagedRecognitions = () =&gt; {&#10;    const filtered = getFilteredRecognitions();&#10;    const total = Math.max(1, Math.ceil(filtered.length / pageSize));&#10;    if (totalPages !== total) setTotalPages(total);&#10;    return filtered.slice(page * pageSize, (page + 1) * pageSize);&#10;  };&#10;&#10;  // Create recognition handler&#10;  const handleCreateInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt; | React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {&#10;    setCreateForm({ ...createForm, [e.target.name]: e.target.value });&#10;  };&#10;  const handleCreate = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    setCreating(true);&#10;    setCreateError('');&#10;    setCreateSuccess('');&#10;    try {&#10;      // You may need to map names to IDs/UUIDs in a real app&#10;      await axios.post('/recognitions', {&#10;        recognitionTypeName: createForm.recognitionTypeName,&#10;        category: createForm.category,&#10;        level: createForm.level,&#10;        awardPoints: Number(createForm.awardPoints),&#10;        senderName: createForm.senderName,&#10;        recipientName: createForm.recipientName,&#10;        message: createForm.message,&#10;      });&#10;      setCreateSuccess('Recognition created successfully');&#10;      setCreateForm({ recognitionTypeName: '', category: '', level: '', awardPoints: '', senderName: '', recipientName: '', message: '' });&#10;      // Reload recognitions&#10;      setTimeout(() =&gt; window.location.reload(), 500); // quick reload for demo&#10;    } catch (err: any) {&#10;      setCreateError('Failed to create recognition');&#10;    } finally {&#10;      setCreating(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div style={{ width: '100%', minHeight: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center' }}&gt;&#10;      &lt;h2 style={{ textAlign: 'center', marginBottom: 24, fontSize: '1.7rem', fontWeight: 600 }}&gt;Recognition Management&lt;/h2&gt;&#10;      {error &amp;&amp; &lt;div style={{ color: 'red', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{error}&lt;/div&gt;}&#10;      {createError &amp;&amp; &lt;div style={{ color: 'red', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{createError}&lt;/div&gt;}&#10;      {createSuccess &amp;&amp; &lt;div style={{ color: 'green', marginBottom: 10, fontSize: '1rem', textAlign: 'center' }}&gt;{createSuccess}&lt;/div&gt;}&#10;      &lt;form onSubmit={handleCreate} style={{ width: '100%', display: 'flex', flexWrap: 'wrap', gap: 10, marginBottom: 20, alignItems: 'center', background: '#fff', padding: 10, borderRadius: 8, boxShadow: '0 2px 8px #e0e0e0', fontSize: '0.7rem', justifyContent: 'center' }}&gt;&#10;        &lt;input name=&quot;recognitionTypeName&quot; placeholder=&quot;Type&quot; value={createForm.recognitionTypeName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;category&quot; placeholder=&quot;Category&quot; value={createForm.category} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;level&quot; placeholder=&quot;Level&quot; value={createForm.level} onChange={handleCreateInputChange} style={{ flex: '1 1 70px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;awardPoints&quot; placeholder=&quot;Points&quot; value={createForm.awardPoints} onChange={handleCreateInputChange} style={{ flex: '1 1 70px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;senderName&quot; placeholder=&quot;Sender Name&quot; value={createForm.senderName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;recipientName&quot; placeholder=&quot;Recipient Name&quot; value={createForm.recipientName} onChange={handleCreateInputChange} required style={{ flex: '1 1 100px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;input name=&quot;message&quot; placeholder=&quot;Message&quot; value={createForm.message} onChange={handleCreateInputChange} required style={{ flex: '2 1 160px', fontSize: '0.7rem', padding: 6 }} /&gt;&#10;        &lt;div style={{ flex: '1 1 100%', display: 'flex', justifyContent: 'center', gap: 10 }}&gt;&#10;          &lt;button type=&quot;submit&quot; disabled={creating} style={{ background: '#1976d2', color: '#fff', border: 'none', borderRadius: 6, padding: '7px 14px', fontSize: '0.7rem', cursor: 'pointer', fontWeight: 500 }}&gt;Create&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;      &lt;div style={{ marginBottom: 12, display: 'flex', justifyContent: 'flex-end', alignItems: 'center', gap: 8, width: '100%' }}&gt;&#10;        &lt;input&#10;          type=&quot;text&quot;&#10;          value={search}&#10;          onChange={e =&gt; setSearch(e.target.value)}&#10;          placeholder=&quot;Search recognitions...&quot;&#10;          style={{ padding: '7px 12px', fontSize: '0.8rem', borderRadius: 6, border: '1px solid #ccc', width: 220 }}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div style={{ marginBottom: 14, display: 'flex', alignItems: 'center', gap: 14, fontSize: '0.7rem', justifyContent: 'center', width: '100%' }}&gt;&#10;        &lt;label&gt;Page Size:&lt;/label&gt;&#10;        &lt;select value={pageSize} onChange={handlePageSizeChange} style={{ padding: 5, fontSize: '0.7rem' }}&gt;&#10;          {PAGE_SIZE_OPTIONS.map(size =&gt; (&#10;            &lt;option key={size} value={size}&gt;{size}&lt;/option&gt;&#10;          ))}&#10;        &lt;/select&gt;&#10;        &lt;span style={{ marginLeft: 16 }}&gt;&#10;          Page: &lt;b&gt;{page + 1}&lt;/b&gt; / &lt;b&gt;{totalPages}&lt;/b&gt;&#10;        &lt;/span&gt;&#10;        &lt;div style={{ display: 'flex', gap: 8 }}&gt;&#10;          &lt;button onClick={() =&gt; handlePageChange(page - 1)} disabled={page &lt;= 0} style={{ padding: '6px 12px', fontSize: '0.7rem', background: '#eee', border: '1px solid #ccc', borderRadius: 6, cursor: page &lt;= 0 ? 'not-allowed' : 'pointer' }}&gt;Prev&lt;/button&gt;&#10;          &lt;button onClick={() =&gt; handlePageChange(page + 1)} disabled={page + 1 &gt;= totalPages} style={{ padding: '6px 12px', fontSize: '0.7rem', background: '#eee', border: '1px solid #ccc', borderRadius: 6, cursor: page + 1 &gt;= totalPages ? 'not-allowed' : 'pointer' }}&gt;Next&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;table style={{ width: '100%', fontSize: '0.7rem', background: '#fff', borderRadius: 8, boxShadow: '0 2px 8px #e0e0e0' }}&gt;&#10;        &lt;thead&gt;&#10;          &lt;tr style={{ background: '#8da1bd' }}&gt;&#10;            {sortableColumns.map(col =&gt; (&#10;              &lt;th&#10;                key={col.key}&#10;                style={{ padding: 8, cursor: 'pointer', userSelect: 'none', whiteSpace: 'nowrap' }}&#10;                onClick={() =&gt; {&#10;                  if (sortField === col.key) {&#10;                    setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');&#10;                  } else {&#10;                    setSortField(col.key);&#10;                    setSortOrder('asc');&#10;                  }&#10;                }}&#10;              &gt;&#10;                {col.label}&#10;                &lt;span style={{ marginLeft: 4, color: sortField === col.key ? '#050505' : '#bbb', fontWeight: 700, fontSize: '1rem', cursor: 'pointer' }}&gt;&#10;                  {sortField === col.key ? (sortOrder === 'asc' ? '▲' : '▼') : '▲▼'}&#10;                &lt;/span&gt;&#10;              &lt;/th&gt;&#10;            ))}&#10;          &lt;/tr&gt;&#10;        &lt;/thead&gt;&#10;        &lt;tbody&gt;&#10;          {getPagedRecognitions().map(rec =&gt; (&#10;            &lt;tr key={rec.id} style={{ background: '#fff' }}&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.id}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.recognitionTypeName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.category}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.level || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.awardPoints}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.senderName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.recipientName || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.message || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.sentAt ? new Date(rec.sentAt * 1000).toLocaleDateString() : '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.approvalStatus || '-'}&lt;/td&gt;&#10;              &lt;td style={{ padding: 8 }}&gt;{rec.rejectionReason || '-'}&lt;/td&gt;&#10;            &lt;/tr&gt;&#10;          ))}&#10;        &lt;/tbody&gt;&#10;      &lt;/table&gt;&#10;      {!loading &amp;&amp; !error &amp;&amp; getPagedRecognitions().length === 0 &amp;&amp; (&#10;        &lt;div style={{ fontSize: '0.7rem', color: '#888', marginTop: 12 }}&gt;No recognitions found.&lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default RecognitionManagement;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/test_import.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test_import.sh" />
              <option name="updatedContent" value="#!/usr/bin/env zsh&#10;set -euo pipefail&#10;&#10;BASE=${BASE:-http://localhost:8080}&#10;CSV=${CSV:-tmp/sample_import.csv}&#10;DEV=${DEV:-true}&#10;&#10;info() { echo &quot;[INFO] $1&quot;; }&#10;err() { echo &quot;[ERROR] $1&quot; &gt;&amp;2; }&#10;&#10;info &quot;Checking server health at $BASE/actuator/health&quot;&#10;if ! curl -sSf &quot;$BASE/actuator/health&quot; &gt;/dev/null; then&#10;  err &quot;Server is not up. Start with: SPRING_DATASOURCE_USERNAME=postgres SPRING_DATASOURCE_PASSWORD=rmkec ./gradlew bootRun -Dapp.dev.enabled=true&quot;&#10;  exit 1&#10;fi&#10;&#10;info &quot;Starting async import via /admin/imports using $CSV&quot;&#10;HTTP_CODE=$(curl -s -o /tmp/import_response.json -w &quot;%{http_code}&quot; -X POST -F &quot;file=@${CSV}&quot; &quot;$BASE/admin/imports&quot;)&#10;cat /tmp/import_response.json | jq . || cat /tmp/import_response.json || true&#10;if [[ &quot;$HTTP_CODE&quot; != &quot;202&quot; &amp;&amp; &quot;$HTTP_CODE&quot; != &quot;200&quot; ]]; then&#10;  err &quot;Import start failed, HTTP $HTTP_CODE&quot;&#10;  exit 2&#10;fi&#10;&#10;JOB_ID=$(jq -r '.jobId // .job_id // empty' /tmp/import_response.json 2&gt;/dev/null || true)&#10;if [[ -z &quot;$JOB_ID&quot; ]]; then&#10;  err &quot;No jobId returned in response. Check /tmp/import_response.json&quot;&#10;  exit 3&#10;fi&#10;info &quot;jobId=$JOB_ID&quot;&#10;&#10;info &quot;Polling job status at /admin/imports/$JOB_ID&quot;&#10;for i in {1..30}; do&#10;  STATUS_JSON=$(curl -s &quot;$BASE/admin/imports/$JOB_ID&quot;)&#10;  STATUS=$(echo &quot;$STATUS_JSON&quot; | jq -r '.status // empty' 2&gt;/dev/null || true)&#10;  echo &quot;$STATUS_JSON&quot; | jq . || echo &quot;$STATUS_JSON&quot;&#10;  if [[ &quot;$STATUS&quot; == &quot;SUCCESS&quot; || &quot;$STATUS&quot; == &quot;PARTIAL&quot; || &quot;$STATUS&quot; == &quot;FAILED&quot; ]]; then&#10;    break&#10;  fi&#10;  sleep 1&#10;done&#10;&#10;info &quot;Fetching errors JSON at /admin/imports/$JOB_ID/errors&quot;&#10;curl -s &quot;$BASE/admin/imports/$JOB_ID/errors?page=0&amp;size=50&quot; | jq . || true&#10;&#10;info &quot;Downloading errors CSV at /admin/imports/$JOB_ID/errors/csv&quot;&#10;curl -s &quot;$BASE/admin/imports/$JOB_ID/errors/csv&quot; -o &quot;import_errors_${JOB_ID}.csv&quot; || true&#10;ls -l &quot;import_errors_${JOB_ID}.csv&quot; || true&#10;&#10;info &quot;Done.&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/controller/AdminV1Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/controller/AdminV1Controller.java" />
              <option name="originalContent" value="package org.example.controller;&#10;&#10;import org.example.service.StagingImportService;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/admin&quot;)&#10;public class AdminV1Controller {&#10;&#10;    private final StagingImportService stagingImportService;&#10;    private final boolean devEnabled;&#10;&#10;    public AdminV1Controller(StagingImportService stagingImportService, @Value(&quot;${app.dev.enabled:false}&quot;) boolean devEnabled) {&#10;        this.stagingImportService = stagingImportService;&#10;        this.devEnabled = devEnabled;&#10;    }&#10;&#10;    @PostMapping(&quot;/imports&quot;)&#10;    public ResponseEntity&lt;?&gt; startImport(@RequestParam MultipartFile file) {&#10;        if (!devEnabled) return ResponseEntity.status(403).body(Map.of(&quot;error&quot;, &quot;admin import disabled&quot;));&#10;        try {&#10;            Map&lt;String, Object&gt; res = stagingImportService.startImportViaCopyAsync(file, file.getOriginalFilename());&#10;            return ResponseEntity.accepted().body(res);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(500).body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/imports/{jobId}&quot;)&#10;    public ResponseEntity&lt;?&gt; getImportStatus(@PathVariable Long jobId) {&#10;        if (!devEnabled) return ResponseEntity.status(403).body(Map.of(&quot;error&quot;, &quot;admin import disabled&quot;));&#10;        try {&#10;            Map&lt;String, Object&gt; status = stagingImportService.getImportJobStatus(jobId);&#10;            return ResponseEntity.ok(status);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(500).body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package org.example.controller;&#10;&#10;// Deprecated stub. Use AdminController (/admin) for admin endpoints.&#10;public class AdminV1Controller {&#10;    // deprecated&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/controller/RecognitionV1Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/controller/RecognitionV1Controller.java" />
              <option name="originalContent" value="package org.example.controller;&#10;&#10;import org.example.dto.RecognitionResponse;&#10;import org.example.dto.StatusUpdateRequest;&#10;import org.example.model.Recognition;&#10;import org.example.model.Employee;&#10;import org.example.repository.EmployeeRepository;&#10;import org.example.repository.RecognitionRepository;&#10;import org.example.service.RecognitionCsvExporter;&#10;import org.example.util.EntityMapper;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;&#10;&#10;import java.io.OutputStream;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/recognitions&quot;)&#10;public class RecognitionV1Controller {&#10;&#10;    private final RecognitionRepository recognitionRepository;&#10;    private final EmployeeRepository employeeRepository;&#10;    private final RecognitionCsvExporter csvExporter;&#10;&#10;    public RecognitionV1Controller(RecognitionRepository recognitionRepository, EmployeeRepository employeeRepository, RecognitionCsvExporter csvExporter) {&#10;        this.recognitionRepository = recognitionRepository;&#10;        this.employeeRepository = employeeRepository;&#10;        this.csvExporter = csvExporter;&#10;    }&#10;&#10;    @GetMapping&#10;    public Page&lt;RecognitionResponse&gt; list(@RequestParam(defaultValue = &quot;0&quot;) int page,&#10;                                         @RequestParam(defaultValue = &quot;20&quot;) int size,&#10;                                         @RequestParam(required = false) Long senderId,&#10;                                         @RequestParam(required = false) UUID senderUuid,&#10;                                         @RequestParam(required = false) Long recipientId,&#10;                                         @RequestParam(required = false) UUID recipientUuid) {&#10;        Pageable p = PageRequest.of(page, size);&#10;&#10;        // prefer uuid if provided&#10;        if (senderUuid != null) {&#10;            Optional&lt;java.util.UUID&gt; su = Optional.of(senderUuid);&#10;            List&lt;Employee&gt; senders = employeeRepository.findAllByUuidIn(List.of(senderUuid)).stream().collect(Collectors.toList());&#10;            if (!senders.isEmpty()) {&#10;                return recognitionRepository.findAllBySenderId(senders.get(0).getId(), p).map(EntityMapper::toRecognitionResponse);&#10;            }&#10;        }&#10;        if (recipientUuid != null) {&#10;            List&lt;Employee&gt; recs = employeeRepository.findAllByUuidIn(List.of(recipientUuid)).stream().collect(Collectors.toList());&#10;            if (!recs.isEmpty()) {&#10;                return recognitionRepository.findAllByRecipientId(recs.get(0).getId(), p).map(EntityMapper::toRecognitionResponse);&#10;            }&#10;        }&#10;&#10;        if (senderId != null) return recognitionRepository.findAllBySenderId(senderId, p).map(EntityMapper::toRecognitionResponse);&#10;        if (recipientId != null) return recognitionRepository.findAllByRecipientId(recipientId, p).map(EntityMapper::toRecognitionResponse);&#10;&#10;        return recognitionRepository.findAllWithRelations(p).map(EntityMapper::toRecognitionResponse);&#10;    }&#10;&#10;    @GetMapping(&quot;/{uuid}&quot;)&#10;    public ResponseEntity&lt;?&gt; getByUuid(@PathVariable UUID uuid) {&#10;        Optional&lt;Recognition&gt; r = recognitionRepository.findByUuidWithRelations(uuid);&#10;        return r.map(rec -&gt; ResponseEntity.ok(EntityMapper.toRecognitionResponse(rec))).orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    // backward-compatible: allow id query&#10;    @GetMapping(params = &quot;id&quot;)&#10;    public ResponseEntity&lt;?&gt; getById(@RequestParam Long id) {&#10;        Optional&lt;Recognition&gt; r = recognitionRepository.findByIdWithRelations(id);&#10;        return r.map(rec -&gt; ResponseEntity.ok(EntityMapper.toRecognitionResponse(rec))).orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PatchMapping(&quot;/{uuid}/status&quot;)&#10;    public ResponseEntity&lt;?&gt; updateStatus(@PathVariable UUID uuid, @RequestBody StatusUpdateRequest req) {&#10;        Optional&lt;Recognition&gt; opt = recognitionRepository.findByUuidWithRelations(uuid);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        Recognition r = opt.get();&#10;        String desired = req != null ? req.status : null;&#10;        if (desired == null) return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;status is required&quot;));&#10;        String upper = desired.toUpperCase();&#10;        if (&quot;APPROVED&quot;.equals(upper)) {&#10;            r.setApprovalStatus(&quot;APPROVED&quot;);&#10;            r.setRejectionReason(null); // clear rejectionReason on approve&#10;        } else if (&quot;REJECTED&quot;.equals(upper)) {&#10;            if (req.rejectionReason == null || req.rejectionReason.isBlank()) return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;rejectionReason required for REJECTED status&quot;));&#10;            r.setApprovalStatus(&quot;REJECTED&quot;);&#10;            r.setRejectionReason(req.rejectionReason);&#10;        } else if (&quot;PENDING&quot;.equals(upper)) {&#10;            r.setApprovalStatus(&quot;PENDING&quot;);&#10;        } else {&#10;            return ResponseEntity.badRequest().body(java.util.Map.of(&quot;error&quot;, &quot;unknown status&quot;));&#10;        }&#10;        recognitionRepository.save(r);&#10;        Recognition reloaded = recognitionRepository.findByUuidWithRelations(r.getUuid()).orElse(r);&#10;        return ResponseEntity.ok(EntityMapper.toRecognitionResponse(reloaded));&#10;    }&#10;&#10;    @GetMapping(&quot;/export&quot;)&#10;    public ResponseEntity&lt;?&gt; export(@RequestParam(defaultValue = &quot;json&quot;) String format,&#10;                                    @RequestParam(defaultValue = &quot;false&quot;) boolean stream,&#10;                                    @RequestParam(required = false) UUID recipientUuid,&#10;                                    @RequestParam(required = false) Long recipientId) throws Exception {&#10;        List&lt;Recognition&gt; list;&#10;        if (recipientUuid != null) {&#10;            List&lt;Employee&gt; recs = employeeRepository.findAllByUuidIn(List.of(recipientUuid));&#10;            if (!recs.isEmpty()) list = recognitionRepository.findAllByRecipientId(recs.get(0).getId(), Pageable.unpaged()).getContent();&#10;            else list = List.of();&#10;        } else if (recipientId != null) {&#10;            list = recognitionRepository.findAllByRecipientId(recipientId, Pageable.unpaged()).getContent();&#10;        } else {&#10;            list = recognitionRepository.findAllWithRelations(Pageable.unpaged()).getContent();&#10;        }&#10;&#10;        if (&quot;csv&quot;.equalsIgnoreCase(format)) {&#10;            if (stream) {&#10;                StreamingResponseBody s = (OutputStream os) -&gt; {&#10;                    try {&#10;                        csvExporter.exportToStream(os, list);&#10;                    } catch (Exception ex) {&#10;                        throw new RuntimeException(ex);&#10;                    }&#10;                };&#10;                return ResponseEntity.ok()&#10;                        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=recognitions.csv&quot;)&#10;                        .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))&#10;                        .body(s);&#10;            } else {&#10;                byte[] bytes = csvExporter.export(list);&#10;                return ResponseEntity.ok()&#10;                        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=recognitions.csv&quot;)&#10;                        .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))&#10;                        .body(bytes);&#10;            }&#10;        } else {&#10;            List&lt;RecognitionResponse&gt; resp = list.stream().map(EntityMapper::toRecognitionResponse).collect(Collectors.toList());&#10;            return ResponseEntity.ok(resp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example.controller;&#10;&#10;// This controller was a v1 prototype and is now deprecated. The canonical endpoints are served by `RecognitionController` at `/recognitions`.&#10;// Kept intentionally empty to avoid duplicate bean registration.&#10;&#10;public class RecognitionV1Controller {&#10;    // deprecated stub&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>